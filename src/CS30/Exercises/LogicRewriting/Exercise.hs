module CS30.Exercises.LogicRewriting.Exercise where

import           CS30.Data
import           CS30.Exercises.Data
import           CS30.Exercises.Util
import qualified Data.Map as Map
import           Data.List
import           CS30.Exercises.LogicRewriting.Parsing (laws, lawNames, Expr (..))
import           CS30.Exercises.LogicRewriting.ProofGeneration (getDerivation, Proof (..))
import           Debug.Trace

-- final exercise type
logicRewritingEx :: ExerciseType
logicRewritingEx = exerciseType "Logic Rewriting" "L?.?" "Logic Rewriting"
                       logicExercises
                       logicQuer
                       logicFeedback

-- display an Expr as a string (to be used with FMath)
-- TODO: display parentheses better
displayExpr :: Expr -> String
displayExpr (Var v)         = [v]
displayExpr (Const b)       = if b then "\\text{true}" else "\\text{false}"
displayExpr (Neg e)         = "\\neg\\left("++(displayExpr e)++"\\right)"
displayExpr (And e1 e2)     = "\\left("++(displayExpr e1)++"\\ \\wedge\\ "++(displayExpr e2)++"\\right)"
displayExpr (Or e1 e2)      = "\\left("++(displayExpr e1)++"\\ \\vee\\ "++(displayExpr e2)++"\\right)"
displayExpr (Implies e1 e2) = "\\left("++(displayExpr e1)++"\\ \\Rightarrow\\ "++(displayExpr e2)++"\\right)"

-- generate initial expressions to put through the proover
-- TODO: decide whether there is a better way to generate "good" expressions
--   (e.g. do we want to have constants in the expression at all? 
--    can we guarantee that at least one variable is in the expression?)
randomExpr :: ChoiceTree Expr
randomExpr = Neg <$> exprOfSize 5
    where exprOfSize :: Int -> ChoiceTree Expr
          exprOfSize 1 = Branch [nodes (map Const [True,False]), 
                                 nodes (map Var ['p','q','r'])]
          exprOfSize 2 = Branch [Neg <$> exprOfSize 1]
          exprOfSize n = Branch ([And <$> exprOfSize i <*> exprOfSize (n-i-1)
                                | i <- [1..(n-2)]] ++ 
                                [Or <$> exprOfSize i <*> exprOfSize (n-i-1)
                                | i <- [1..(n-2)]] ++ 
                                [Implies <$> exprOfSize i <*> exprOfSize (n-i-1)
                                | i <- [1..(n-2)]])

-- contains all the exercises: the list of Fields is what we display
-- and the String is the solution (actually just the index of the right choice)
logicExercises :: [ChoiceTree ([Field], String)]
logicExercises = [do e <- randomExpr
                     let (Proof e' steps) = getDerivation laws e
                     remStep <- nodes [0..(length steps - 1)]
                     let (stepName, stepE) = steps!!remStep
                     choices <- (getOrderedSubset (delete stepName lawNames) 2)
                     correctN <- nodes [0..2]
                     let shuffChoices = putElemIn stepName correctN choices 
                     return (showExer (Proof e' steps) remStep shuffChoices, show correctN)
                  ]
                 where putElemIn :: a -> Int -> [a] -> [a]
                       putElemIn y 0 xs = y:xs
                       putElemIn y n (x:xs) = x:(putElemIn y (n-1) xs)
                       displayStepsExcept _ [] _  = []
                       displayStepsExcept n (s:rem) choices = [FMath "\\equiv", name, 
                                                               FIndented 1 [FMath $ displayExpr (snd s)]]
                                                              ++ displayStepsExcept (n-1) rem choices
                                                              where correct = FText ("{ "++(fst s)++" }")
                                                                    name = if n/=0 then correct
                                                                           else FChoice "choice" (map (\x -> [FText $ "{ "++x++" }"]) choices)

                       showExer (Proof e steps) remStep choices = [FIndented 1 [FMath $ displayExpr e]] 
                                                                  ++ (displayStepsExcept remStep steps choices)

-- generate the question displayed to the user
logicQuer :: ([Field], String) -> Exercise -> Exercise
logicQuer (quer, _) defExer = defExer {eQuestion = quer}

-- generate feedback
logicFeedback :: ([Field], String) -> Map.Map String String -> ProblemResponse -> ProblemResponse
logicFeedback (_, sol) mStrs defaultRsp 
    = case rsp of 
        Just v -> if v == sol then markCorrect $ defaultRsp{prFeedback = [FText "Correct"]}
                  else if v == "" then markWrong $ defaultRsp{prFeedback = [FText "Please select which law is applied"]}
                       else markWrong $ defaultRsp{prFeedback = [FText "Incorrect"]} 
        Nothing -> markWrong $ defaultRsp{prFeedback = [FText "We could not understand your answer"]}
        -- ^ TODO: give better feedback (probably need to change the solution data structure to show the correct answer)
    where rsp = Map.lookup "choice" mStrs
